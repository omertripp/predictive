\section{Trace Encoding}

In this section, we describe how a concrete execution trace is encoded as a symbolic trace, which enables \tool\ to 
derive reordering constraints.

\subsection{Preliminaries}

Throughout this paper, we assume a standard operational semantics, which defines (i) a mapping ${\sf thr}$ between
execution threads, each having a unique identifier $i \in \mathbb{N}$, and their respective code, as well as (ii) per-thread stack and shared heap memory. The code executed by a given thread follows the syntax in Table \ref{Ta:syntax}. In the starting state, each thread points to a parameter-free method.

As is standard, we assume an interleaved semantics of concurrency. A \emph{transition}, or \emph{event}, is of the form
$\sigma \stackrel{i / {\tt s}}{\longrightarrow} \sigma'$, denoting that thread $i$ took an evaluation step
in prestate $\sigma$, wherein atomic
statement {\tt s} was executed, which resulted in poststate $\sigma'$. We refer to a sequence of transitions from
the starting state to either an exceptional state (e.g., due to null dereference) or a state where all the threads have 
reduced their respective code to $\epsilon$ as a \emph{trace}.

\begin{table}
	\begin{center}
	\begin{tabular}{rl}
						\multicolumn{1}{l}{{\tt p} $::=$} & \\
					    $\overline{\texttt{r m($\overline{{\tt x}}$) \{ s \}}}$ & {\bf (method)} \\
						\multicolumn{1}{l}{{\tt s} $::=$} & \\
						{\tt x = y}\ $|$\ {\tt x = $c$} $|$\ & {\bf (assignment)} \\
						{\tt x = new()} $|$\ & {\bf (allocation)} \\
						{\tt x = f($\overline{{\tt y}}$)} $|$\ & {\bf (invocation)} \\
						{\tt z = x \{ $+$,$-$,$\times$,$/$ \} y}\ $|$\ & {\bf (aexp)} \\
						{\tt b = x \{ $<$,$\leq$,$\equiv$,$\geq$,$>$ \} y}\ $|$\ & {\bf (comparison)} \\
						{\tt b = bx $\wedge$ by}\ $|$\ {\tt b = bx $\vee$ by} $|$\ & {\bf (bexp)} \\
						{\tt y = x.f} $|$\ {\tt x.f = y}\ $|$\ & {\bf (heap)} \\
						{\tt if (b) \{ s \} $|$\ {\tt while (b) \{  s \}} $|$\ {\tt s ; s }} $|$\ & {\bf (control)} \\
						{\tt lock(x)}\ $|$\ {\tt unlock(x)} & {\bf (sync)}
	\end{tabular}
	\end{center}
	\caption{\label{Ta:syntax}Language syntax}
\end{table}

We make use of the following helper functions:
\begin{itemize}
	\item ${\sf proj}\ t\ i$ projects trace $t$ onto all transitions involving thread $i$.
	\item $t[k]$ obtains the $k$th transition within trace $t$.
	\item ${\sf pre}\ t\ \tau$ is the prefix of trace $t$ preceding transition $\tau$. For the suffix beyond $\tau$, we 
	use ${\sf post}\ t\ \tau$. Finally, ${\sf bet}\ t\ \tau_1\ \tau_2$ returns the transitions delimited by $\tau_1$ and $\tau_2$.
\end{itemize}

\subsection{Basic Encoding}

We describe how \tool\ encodes a trace into symbolic form in two steps. We first start with ``local'' intraprocedural events --- i.e., 
transitions that manipulate memory accessed by at most a single thread during an invocation-free run --- and then extend our encoding scheme to the entire set of possible events.

The fundamental encoding transformation is to induce Static Single Assignment (SSA) form on the raw trace, such that
a variable is defined exactly once. In this way, def/use chains become explicit, and encoding of trace events as constraints is simplified. As an illustration, trace
\begin{quote}
	{\tt x=1; x<3; x=3; y=1; z=x+y}
\end{quote}
becomes
\begin{quote}
	{\tt x$^0$=1; x$^0$<3; x$^1$=3; y$^0$=1; z$^0$=x$^1$+y$^0$}
\end{quote}

Beyond the default SSA rewriting algorithm, we apply a specialized transformation to handle local heap accesses.\footnote{
	Note that while in general determining whether a given heap access is local is an undecidable problem, in the context
	of a concrete execution trace this determination is straightforward.
} We replace accesses to field {\tt f} of local object {\tt x} with a fresh local variable {\tt l$_{\tt x.f}$}. This is done prior to the standard SSA transformation, and under the assumption that the heap object pointed-to by {\tt x} will remain the same in the predicted trace.

\subsection{Advanced Encoding}