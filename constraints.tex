\section{Exploration of Unexecuted Branches}

We now switch to the second feature of \tool, which is its ability to reason about unexplored branches.

\paragraph{Relaxation of Branching Decisions}

Beyond relaxing flow dependencies, \tool\ is also capable of exploring code branches that were not executed in the original trace. This is achieved via a symbolic representation of the input trace. Given branching event $e_b$,
\begin{enumerate}
	\item model the branching condition symbolically to execute along the negation of the original branch;
	\item apply depth-first search (DFS) to uncover all execution suffixes under the unexplored branch (which may itself contain branching statements); and
	\item for each suffix $t^s$,
	\begin{enumerate}
		\item truncate the original trace at $e_b$ yielding prefix $t_s$; and
		\item concatenate $t_s$ with the negation of $e_b$ followed by $t^s$.
	\end{enumerate}
\end{enumerate}
Constraint solving is applied to each of the resulting traces analogously to the original trace.

We emphasize that exploration of new execution paths is subject to all the known limitations of symbolic execution, including in particular loop structures and object allocation. \tool\ currently fails if (i) the unexplored branch containts loops or (ii) there are object references that cannot be fully resolved at the branching point. In case of failure, \tool\ moves on to other branches. We demonstrate in Section \ref{sec:eval} that despite these limitations, the increase in coverage thanks to exploration of new paths is significant.

\paragraph{Proof of Correctness}

\input{proof}