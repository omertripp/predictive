\section{Implementation}\label{sec:impl}


\subsection{Time Window and Initial Value constraints}~\label{sec:timewindow}
The trace is typically long and the constraint solver cannot scale to the whole trace. Instead, we adopt the notion of time window. 
We divide the trace into $N$ traces of the same length, where $N$ is configurable parameter (1000 in our experiment). To support the time window, we need to store the values of the shared variables and local variables at the end of a window and encode such values as the inputs of the next window. 

We maintain two maps,  $sstore$ and $lstore$, for the shared variables and local variables respectively. Suppose the trace for the last window is $\tau$. The following code illustrates how we maintain the $sstore$, i.e., storing the value written by the last write with each address. Beside, the variable $e.ins.left$ represents the left hand variable inside the instruction $e.ins$.

\begin{algorithmic}[3]
\For {$a \in \mathcal{A}$}
 \State $\tau_a=W(a)$
 \State $sstore.put(a,\tau_a[|\tau_a|-1].v)$ 
\EndFor
\end{algorithmic}

%TODO define left:
\begin{algorithmic}[3]
\For {$e \in \tau$}
  \If {$e.isLocalAcc()$}
    \State $ lstore.put(e.ins.left, e.v)$
  \Else
     \If{$e.isRead()$}      
        \State $ lstore.put(e.ins.left, e.v)$
     \EndIf
  \EndIf 
\EndFor
\end{algorithmic}


When constructing the constraints for the next window, we specify the following constraints to encode the input values.

The following formula enhances the thread interfernce constraint to include the case that the read reads from the initial values. 

$\Phi_{TI}=\Phi_{TI} \wedge  R=sstore.get(e_R.a) \wedge \bigvee_{e\in S} O(e_R)<O(e)$.

The following formula encodes the input values of local variables. 

$\Phi_{IN}=\bigvee_{l\in lstore.keys()} l=lstore.get(l)$.
 


For array access event $arr[i]=x$, we treat them as the field access event $arr.i=x$, where the index $i$ is treated as a field. 

We distinguish the accesses of the shared fields and local fields. To collect the shared fields, we preprocess the trace and map each field to a set of accessing threads. If a field is written by two or more threads, it is shared. If a field is written by one thread and read by other threads, it is shared. Otherwise, it is a local field. 

optimization. Before the symbolic analysis, we conduct the backward slicing by treating the racy pair as the seeds. Only those selected in the slices are preserved while the rest events are ignored. 
